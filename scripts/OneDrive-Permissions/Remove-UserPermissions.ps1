<#
.SYNOPSIS
    Remove user permissions from OneDrives based on CSV reports from permission scanning tools.

.DESCRIPTION
    This script processes CSV reports generated by Check-OneDrivePermissions.ps1 or 
    Scan-AllOneDrivesForUser.ps1 to safely remove specified user permissions from OneDrives.
    
    CRITICAL SAFETY FEATURE: The script will NEVER remove permissions from a user's own OneDrive.
    It only removes permissions where the target user has been granted access to someone else's OneDrive.

.PARAMETER InputCsvPath
    Path to CSV file generated by permission scanning tools

.PARAMETER TargetUserEmail
    Email of the user whose permissions should be removed (must match CSV data)

.PARAMETER TenantId
    Azure AD Tenant ID (optional, will prompt if not provided)

.PARAMETER ClientId
    Application Client ID for authentication (optional, uses interactive auth if not provided)

.PARAMETER CertificatePath
    Path to certificate file (.pfx) for certificate authentication

.PARAMETER CertificatePassword
    Certificate password for certificate authentication

.PARAMETER ClientSecret
    Client Secret for app authentication

.PARAMETER AuthMethod
    Authentication method: Interactive, Certificate, or ClientSecret

.PARAMETER DryRun
    Preview changes without actually removing permissions (default: $true)

.PARAMETER BatchSize
    Number of permissions to process in each batch (default: 10)

.PARAMETER LogPath
    Path for detailed audit log (optional, defaults to script directory)

.PARAMETER Force
    Skip confirmation prompts (use with caution)

.EXAMPLE
    .\Remove-UserPermissions.ps1 -InputCsvPath "C:\Reports\permissions.csv" -TargetUserEmail "user@company.com" -DryRun $true

.EXAMPLE
    .\Remove-UserPermissions.ps1 -InputCsvPath "C:\Reports\permissions.csv" -TargetUserEmail "user@company.com" -CertificatePath "C:\cert.pfx" -ClientId "guid" -TenantId "guid" -DryRun $false

.NOTES
    Author: Ruben Quispe
    Created: 2023-06-24
    Requires: Microsoft.Graph PowerShell Module
    Permissions Required: Files.ReadWrite.All, User.Read.All, Sites.ReadWrite.All
    
    SAFETY WARNING: This script modifies OneDrive permissions. Always run with -DryRun $true first!
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory = $false, HelpMessage = "Path to CSV file from permission scan")]
    [string]$InputCsvPath,
    
    [Parameter(Mandatory = $false, HelpMessage = "Email of user whose permissions to remove")]
    [string]$TargetUserEmail,
    
    [Parameter(Mandatory = $false, HelpMessage = "Azure AD Tenant ID")]
    [string]$TenantId,
    
    [Parameter(Mandatory = $false, HelpMessage = "Application Client ID")]
    [string]$ClientId,
    
    [Parameter(Mandatory = $false, HelpMessage = "Path to certificate file (.pfx)")]
    [string]$CertificatePath,
    
    [Parameter(Mandatory = $false, HelpMessage = "Certificate password")]
    [SecureString]$CertificatePassword,
    
    [Parameter(Mandatory = $false, HelpMessage = "Client Secret for app authentication")]
    [SecureString]$ClientSecret,
    
    [Parameter(Mandatory = $false, HelpMessage = "Authentication method")]
    [string]$AuthMethod,
    
    [Parameter(Mandatory = $false, HelpMessage = "Preview mode - no actual changes")]
    [bool]$DryRun = $true,
    
    [Parameter(Mandatory = $false, HelpMessage = "Batch processing size")]
    [int]$BatchSize = 10,
    
    [Parameter(Mandatory = $false, HelpMessage = "Audit log file path")]
    [string]$LogPath,
    
    [Parameter(Mandatory = $false, HelpMessage = "Skip confirmation prompts")]
    [switch]$Force,
    
    [Parameter(Mandatory = $false, HelpMessage = "Enable detailed debug output")]
    [switch]$DebugMode
)

# Add reference to System.Web for HttpUtility
Add-Type -AssemblyName System.Web

# Global variables
$Script:ProcessedPermissions = 0
$Script:RemovedPermissions = 0
$Script:SkippedPermissions = 0
$Script:ErrorPermissions = @()
$Script:SafetySkipped = 0
$Script:CachedCertificate = $null
$Script:StartTime = $null
$Script:AuditLog = @()
$Script:PermissionsData = @()

#region Helper Functions (Reused from other scripts)

function Write-ColorOutput {
    param(
        [string]$Message,
        [string]$Color = "White"
    )
    Write-Host $Message -ForegroundColor $Color
    
    # Also log to audit trail
    Add-AuditEntry -Message $Message -Type "Info"
}

function Add-AuditEntry {
    param(
        [string]$Message,
        [string]$Type = "Info",
        [string]$OneDriveOwner = "",
        [string]$ItemPath = "",
        [string]$PermissionId = "",
        [string]$Action = ""
    )
    
    $AuditEntry = [PSCustomObject]@{
        Timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        Type = $Type
        Message = $Message
        OneDriveOwner = $OneDriveOwner
        ItemPath = $ItemPath
        PermissionId = $PermissionId
        Action = $Action
        TargetUser = $TargetUserEmail
    }
    
    $Script:AuditLog += $AuditEntry
}

function Install-RequiredModules {
    Write-ColorOutput "Checking required PowerShell modules..." "Yellow"
    
    # Define required modules with specific versions if needed
    $RequiredModules = @(
        @{Name = "Microsoft.Graph.Authentication"; MinVersion = "1.20.0"},
        @{Name = "Microsoft.Graph.Users"; MinVersion = "1.20.0"},
        @{Name = "Microsoft.Graph.Files"; MinVersion = "1.20.0"},
        @{Name = "Microsoft.Graph.Sites"; MinVersion = "1.20.0"}  # Added Sites module which is often needed
    )
    
    # Required cmdlets that must be available
    $RequiredCmdlets = @(
        "Connect-MgGraph",
        "Get-MgUser",
        "Get-MgUserDrive",
        "Get-MgDriveRoot",
        "Get-MgDriveItemPermission",
        "Remove-MgDriveItemPermission",
        "Get-MgDriveItemChild"  # Only require cmdlets that actually exist
    )
    
    # Install or update modules
    foreach ($ModuleInfo in $RequiredModules) {
        $ModuleName = $ModuleInfo.Name
        $MinVersion = $ModuleInfo.MinVersion
        
        # Check if module is installed
        $InstalledModule = Get-Module -ListAvailable -Name $ModuleName | Sort-Object Version -Descending | Select-Object -First 1
        
        if (-not $InstalledModule) {
            Write-ColorOutput "Installing module: $ModuleName (minimum version: $MinVersion)" "Yellow"
            try {
                Install-Module -Name $ModuleName -MinimumVersion $MinVersion -Force -AllowClobber -Scope CurrentUser
                Write-ColorOutput "Successfully installed $ModuleName" "Green"
            }
            catch {
                Write-ColorOutput "Failed to install $ModuleName. Error: $($_.Exception.Message)" "Red"
                Write-ColorOutput "Please run: Install-Module -Name $ModuleName -MinimumVersion $MinVersion -Force -AllowClobber -Scope CurrentUser" "Yellow"
                return $false
            }
        }
        else {
            # Check if installed version meets minimum requirement
            if ($MinVersion -and $InstalledModule.Version -lt [Version]$MinVersion) {
                Write-ColorOutput "Updating module: $ModuleName to minimum version $MinVersion (current: $($InstalledModule.Version))" "Yellow"
                try {
                    Update-Module -Name $ModuleName -RequiredVersion $MinVersion -Force
                    Write-ColorOutput "Successfully updated $ModuleName to version $MinVersion" "Green"
                }
                catch {
                    Write-ColorOutput "Failed to update $ModuleName. Error: $($_.Exception.Message)" "Red"
                    Write-ColorOutput "Please run: Update-Module -Name $ModuleName -RequiredVersion $MinVersion -Force" "Yellow"
                    return $false
                }
            }
            else {
                Write-ColorOutput "Module $ModuleName is already installed (Version: $($InstalledModule.Version))" "Green"
            }
        }
    }
    
    # Import modules
    foreach ($ModuleInfo in $RequiredModules) {
        $ModuleName = $ModuleInfo.Name
        try {
            Import-Module $ModuleName -Force -ErrorAction Stop
            Write-ColorOutput "Successfully imported $ModuleName" "Green"
        }
        catch {
            Write-ColorOutput "Failed to import $ModuleName. Error: $($_.Exception.Message)" "Red"
            return $false
        }
    }
    
    # Verify required cmdlets are available
    $MissingCmdlets = @()
    foreach ($Cmdlet in $RequiredCmdlets) {
        if (-not (Get-Command -Name $Cmdlet -ErrorAction SilentlyContinue)) {
            $MissingCmdlets += $Cmdlet
        }
    }
    
    if ($MissingCmdlets.Count -gt 0) {
        Write-ColorOutput "WARNING: The following required cmdlets are missing:" "Red"
        foreach ($MissingCmdlet in $MissingCmdlets) {
            Write-ColorOutput "  - $MissingCmdlet" "Red"
        }
        
        # Check if the critical cmdlet Get-MgDriveItemChild is missing
        if ($MissingCmdlets -contains "Get-MgDriveItemChild") {
            Write-ColorOutput "Critical cmdlet Get-MgDriveItemChild is missing. This is required for folder navigation." "Red"
            Write-ColorOutput "Please install the Microsoft.Graph.Files module:" "Yellow"
            Write-ColorOutput "Install-Module Microsoft.Graph.Files -Force" "Yellow"
            return $false
        }
        
        # For non-critical cmdlets, we can continue with fallback methods
        Write-ColorOutput "Some non-critical cmdlets are missing, but the script can continue using fallback methods." "Yellow"
    }
    
    Write-ColorOutput "All required modules and cmdlets are available" "Green"
    return $true
}

function Connect-ToGraph {
    Write-ColorOutput "Connecting to Microsoft Graph using $($Script:AuthMethod) authentication..." "Yellow"
    
    $RequiredScopes = @("Files.ReadWrite.All", "User.Read.All", "Sites.ReadWrite.All")
    
    try {
        switch ($Script:AuthMethod) {
            "Certificate" {
                # Certificate-based authentication - use cached certificate
                if ($Script:CachedCertificate) {
                    $Certificate = $Script:CachedCertificate
                } else {
                    if ($Script:CertificatePassword) {
                        $Certificate = Get-PfxCertificate -FilePath $Script:CertificatePath -Password $Script:CertificatePassword
                    } else {
                        $Certificate = Get-PfxCertificate -FilePath $Script:CertificatePath
                    }
                    $Script:CachedCertificate = $Certificate
                }
                
                Connect-MgGraph -ClientId $Script:ClientId -TenantId $Script:TenantId -Certificate $Certificate
                Write-ColorOutput "Connected using certificate authentication." "Green"
            }
            
            "ClientSecret" {
                # Client Secret authentication
                $ClientSecretCredential = New-Object System.Management.Automation.PSCredential($Script:ClientId, $Script:ClientSecret)
                Connect-MgGraph -TenantId $Script:TenantId -ClientSecretCredential $ClientSecretCredential
                Write-ColorOutput "Connected using client secret authentication." "Green"
            }
            
            "Interactive" {
                # Interactive authentication
                if ($Script:TenantId) {
                    Connect-MgGraph -TenantId $Script:TenantId -Scopes $RequiredScopes
                } else {
                    Connect-MgGraph -Scopes $RequiredScopes
                }
                Write-ColorOutput "Connected using interactive authentication." "Green"
            }
            
            default {
                # Fallback to interactive
                Connect-MgGraph -Scopes $RequiredScopes
                Write-ColorOutput "Connected using interactive authentication (fallback)." "Green"
            }
        }
        
        # Verify connection and display tenant info
        $Context = Get-MgContext
        if ($Context) {
            Write-ColorOutput "Successfully connected to tenant: $($Context.TenantId)" "Green"
            
            # Try to get tenant details for confirmation
            try {
                $TenantInfo = Get-MgOrganization -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($TenantInfo) {
                    Write-ColorOutput "Organization: $($TenantInfo.DisplayName)" "Green"
                }
            }
            catch {
                # Ignore if can't get org info
            }
            
            return $true
        } else {
            Write-ColorOutput "Failed to establish Graph context." "Red"
            return $false
        }
    }
    catch {
        Write-ColorOutput "Failed to connect to Microsoft Graph. Error: $($_.Exception.Message)" "Red"
        
        # Provide specific guidance based on auth method
        switch ($Script:AuthMethod) {
            "Certificate" {
                Write-ColorOutput "Certificate authentication troubleshooting:" "Yellow"
                Write-ColorOutput "- Verify certificate is uploaded to your Azure app registration" "Yellow"
                Write-ColorOutput "- Ensure app has required permissions: Files.ReadWrite.All, User.Read.All, Sites.ReadWrite.All" "Yellow"
                Write-ColorOutput "- Check that admin consent has been granted" "Yellow"
            }
            "ClientSecret" {
                Write-ColorOutput "Client secret authentication troubleshooting:" "Yellow"
                Write-ColorOutput "- Verify client secret is valid and not expired" "Yellow"
                Write-ColorOutput "- Ensure app has required permissions: Files.ReadWrite.All, User.Read.All, Sites.ReadWrite.All" "Yellow"
                Write-ColorOutput "- Check that admin consent has been granted" "Yellow"
            }
            "Interactive" {
                Write-ColorOutput "Interactive authentication troubleshooting:" "Yellow"
                Write-ColorOutput "- Ensure you have SharePoint Administrator or Global Administrator role" "Yellow"
                Write-ColorOutput "- Try clearing browser cache or using incognito mode" "Yellow"
            }
        }
        
        return $false
    }
}

function Get-UserInput {
    param(
        [string]$Prompt,
        [bool]$Required = $true,
        [switch]$IsFilePath
    )
    
    do {
        $Input = Read-Host $Prompt
        if (-not $Required -or $Input.Trim()) {
            if ($IsFilePath -and $Input.Trim()) {
                if (-not (Test-Path $Input.Trim())) {
                    Write-ColorOutput "File not found: $($Input.Trim()). Please enter a valid file path." "Red"
                    continue
                }
            }
            return $Input.Trim()
        }
        Write-ColorOutput "This field is required. Please enter a value." "Red"
    } while ($Required)
}

function Show-AuthMethodMenu {
    Write-Host ""
    Write-ColorOutput "Select Authentication Method:" "Yellow"
    Write-Host "1. Interactive Login (Browser-based - Recommended for first time)"
    Write-Host "2. Certificate Authentication (.pfx file)"
    Write-Host "3. App Registration with Client Secret"
    Write-Host ""
    
    do {
        $Choice = Read-Host "Choose authentication method [1-3]"
        switch ($Choice) {
            "1" { return "Interactive" }
            "2" { return "Certificate" }
            "3" { return "ClientSecret" }
            default { Write-ColorOutput "Invalid choice. Please enter 1, 2, or 3." "Red" }
        }
    } while ($true)
}

function Get-SecureInput {
    param(
        [string]$Prompt
    )
    
    do {
        $SecureInput = Read-Host $Prompt -AsSecureString
        if ($SecureInput.Length -gt 0) {
            return $SecureInput
        }
        Write-ColorOutput "This field is required. Please enter a value." "Red"
    } while ($true)
}

function Test-GuidFormat {
    param(
        [string]$InputString
    )
    
    try {
        $null = [System.Guid]::Parse($InputString)
        return $true
    }
    catch {
        return $false
    }
}

function Get-AuthenticationDetails {
    # Auto-detect authentication method if not specified
    if (-not $Script:AuthMethod) {
        if ($Script:CertificatePath) {
            $Script:AuthMethod = "Certificate"
            Write-ColorOutput "Auto-detected Certificate authentication method." "Green"
        } elseif ($Script:ClientSecret) {
            $Script:AuthMethod = "ClientSecret"
            Write-ColorOutput "Auto-detected Client Secret authentication method." "Green"
        } else {
            $Script:AuthMethod = Show-AuthMethodMenu
        }
    }
    
    Write-Host ""
    Write-ColorOutput "Setting up $($Script:AuthMethod) authentication..." "Yellow"
    
    switch ($Script:AuthMethod) {
        "Certificate" {
            if (-not $Script:CertificatePath) {
                $Script:CertificatePath = Get-UserInput "Enter certificate file path (.pfx)" -IsFilePath
            }
            
            # ALWAYS force a certificate password prompt for Certificate auth mode
            # This ensures we get the password even in dry run mode and even if it was provided as a parameter
            Write-ColorOutput "Certificate authentication requires a password." "Yellow"
            $Script:CertificatePassword = Get-SecureInput "Enter certificate password"
            
            # Only try to load the certificate if not in dry run mode
            if (-not $DryRun) {
                # Test if certificate can be loaded and cache it
                try {
                    $Script:CachedCertificate = Get-PfxCertificate -FilePath $Script:CertificatePath -Password $Script:CertificatePassword -ErrorAction Stop
                    Write-ColorOutput "Certificate loaded successfully." "Green"
                }
                catch {
                    Write-ColorOutput "Error loading certificate: $($_.Exception.Message)" "Red"
                    return $false
                }
            } else {
                Write-ColorOutput "Certificate validation skipped in dry run mode." "Yellow"
            }
            
            if (-not $Script:ClientId) {
                do {
                    $Script:ClientId = Get-UserInput "Enter Application Client ID (GUID format)"
                    if (-not (Test-GuidFormat $Script:ClientId)) {
                        Write-ColorOutput "Invalid GUID format. Please enter a valid Client ID." "Red"
                        $Script:ClientId = ""
                    }
                } while (-not $Script:ClientId)
            }
            
            if (-not $Script:TenantId) {
                do {
                    $Script:TenantId = Get-UserInput "Enter Tenant ID (GUID format)"
                    if (-not (Test-GuidFormat $Script:TenantId)) {
                        Write-ColorOutput "Invalid GUID format. Please enter a valid Tenant ID." "Red"
                        $Script:TenantId = ""
                    }
                } while (-not $Script:TenantId)
            }
        }
        
        "ClientSecret" {
            if (-not $Script:ClientId) {
                do {
                    $Script:ClientId = Get-UserInput "Enter Application Client ID (GUID format)"
                    if (-not (Test-GuidFormat $Script:ClientId)) {
                        Write-ColorOutput "Invalid GUID format. Please enter a valid Client ID." "Red"
                        $Script:ClientId = ""
                    }
                } while (-not $Script:ClientId)
            }
            
            if (-not $Script:TenantId) {
                do {
                    $Script:TenantId = Get-UserInput "Enter Tenant ID (GUID format)"
                    if (-not (Test-GuidFormat $Script:TenantId)) {
                        Write-ColorOutput "Invalid GUID format. Please enter a valid Tenant ID." "Red"
                        $Script:TenantId = ""
                    }
                } while (-not $Script:TenantId)
            }
            
            if (-not $Script:ClientSecret) {
                $Script:ClientSecret = Get-SecureInput "Enter Client Secret"
            }
        }
        
        "Interactive" {
            Write-ColorOutput "Interactive authentication selected. You will be prompted to sign in via browser." "Green"
            # No additional parameters needed for interactive auth
        }
    }
    
    return $true
}

#endregion

#region Core Graph API Functions

function Get-UserDriveId {
    param(
        [string]$UserEmail
    )
    
    try {
        Write-ColorOutput "    [SEARCH] Resolving OneDrive for user: $UserEmail" "DarkYellow"
        
        # Get user information first
        $User = Get-MgUser -UserId $UserEmail -ErrorAction Stop
        if (-not $User) {
            Write-ColorOutput "    [ERROR] User not found: $UserEmail" "Red"
            return $null
        }
        
        # Get user's OneDrive (default drive)
        $Drives = Get-MgUserDrive -UserId $User.Id -ErrorAction Stop
        
        if (-not $Drives) {
            Write-ColorOutput "    [ERROR] OneDrive not found for user: $UserEmail" "Red"
            return $null
        }
        
        # Handle case where multiple drives are returned
        $PrimaryDrive = $null
        
        if ($Drives -is [array]) {
            Write-ColorOutput "    [INFO] Multiple drives found, selecting primary OneDrive" "Yellow"
            
            # Try to find the business OneDrive first
            $BusinessDrive = $Drives | Where-Object { $_.DriveType -eq "business" -or $_.Name -eq "OneDrive" } | Select-Object -First 1
            
            if ($BusinessDrive) {
                $PrimaryDrive = $BusinessDrive
                Write-ColorOutput "    [INFO] Selected business OneDrive" "Yellow"
            } else {
                # Fallback to first drive
                $PrimaryDrive = $Drives[0]
                Write-ColorOutput "    [INFO] Selected first available drive" "Yellow"
            }
        } else {
            # Single drive returned
            $PrimaryDrive = $Drives
        }
        
        # Ensure we have a clean drive ID (sometimes IDs can have spaces or multiple values)
        $DriveId = $PrimaryDrive.Id
        
        # If the drive ID contains spaces, take only the first part
        if ($DriveId -match '\s') {
            $DriveId = $DriveId.Split()[0]
            Write-ColorOutput "    [INFO] Multiple drive IDs detected, using first ID: $DriveId" "Yellow"
        }
        
        Write-ColorOutput "    [OK] Found OneDrive: $DriveId" "Green"
        return $DriveId
        
    }
    catch {
        Write-ColorOutput "    [ERROR] Error getting OneDrive for $UserEmail - $($_.Exception.Message)" "Red"
        return $null
    }
}

function Find-DriveItemByPath {
    param(
        [string]$DriveId,
        [string]$ItemPath
    )
    
    try {
        Write-ColorOutput "    [SEARCH] Finding item: $ItemPath" "DarkYellow"
        
        # Clean up the path - remove leading slashes and "Documents" if present
        $CleanPath = $ItemPath.TrimStart('/')
        if ($CleanPath.StartsWith('Documents/')) {
            $CleanPath = $CleanPath.Substring('Documents/'.Length)
        }
        
        # Always use the fallback method since the direct path methods don't exist
        Write-ColorOutput "    [INFO] Using folder navigation method to find item" "Yellow"
        return Find-DriveItemByPathFallback -DriveId $DriveId -ItemPath $CleanPath
        
    }
    catch {
        Write-ColorOutput "    [ERROR] Error finding item $ItemPath - $($_.Exception.Message)" "Red"
        return $null
    }
}

function Find-DriveItemByPathFallback {
    param(
        [string]$DriveId,
        [string]$ItemPath
    )
    
    Write-ColorOutput "    [METHOD] Using folder navigation to find item: $ItemPath" "Yellow"
    
    try {
        # Ensure we have a clean drive ID (sometimes IDs can have spaces or multiple values)
        if ($DriveId -match '\s') {
            $DriveId = $DriveId.Split()[0]
            Write-ColorOutput "    [INFO] Cleaned drive ID for navigation: $DriveId" "Yellow"
        }
        
        # Start at the root
        if (-not (Get-Command -Name Get-MgDriveRoot -ErrorAction SilentlyContinue)) {
            Write-ColorOutput "    [ERROR] Command Get-MgDriveRoot not available. Cannot use fallback method." "Red"
            return $null
        }
        
        try {
            $CurrentItem = Get-MgDriveRoot -DriveId $DriveId -ErrorAction Stop
        }
        catch {
            Write-ColorOutput "    [ERROR] Failed to get root: $($_.Exception.Message)" "Red"
            
            # Try alternative method for getting root
            try {
                Write-ColorOutput "    [INFO] Trying alternative method to get root" "Yellow"
                $CurrentItem = Get-MgDriveItem -DriveId $DriveId -DriveItemId "root" -ErrorAction Stop
            }
            catch {
                Write-ColorOutput "    [ERROR] Alternative method also failed: $($_.Exception.Message)" "Red"
                return $null
            }
        }
        
        $CurrentItemId = $CurrentItem.Id
        
        # Split path into components
        $PathComponents = $ItemPath.Split('/', [StringSplitOptions]::RemoveEmptyEntries)
        
        if ($PathComponents.Count -eq 0) {
            return $CurrentItemId
        }
        
        # Navigate through each path component
        foreach ($Component in $PathComponents) {
            if (-not (Get-Command -Name Get-MgDriveItemChild -ErrorAction SilentlyContinue)) {
                Write-ColorOutput "    [ERROR] Command Get-MgDriveItemChild not available. Cannot use fallback method." "Red"
                return $null
            }
            
            try {
                $Children = Get-MgDriveItemChild -DriveId $DriveId -DriveItemId $CurrentItemId -ErrorAction Stop
                
                # Case-insensitive matching
                $MatchingChild = $Children | Where-Object { $_.Name -ieq $Component } | Select-Object -First 1
                
                if (-not $MatchingChild) {
                    # Try fuzzy matching if exact match fails
                    Write-ColorOutput "    [INFO] Exact match not found for '$Component', trying fuzzy matching" "Yellow"
                    $MatchingChild = $Children | Where-Object { $_.Name -like "*$Component*" } | Select-Object -First 1
                }
                
                if (-not $MatchingChild) {
                    Write-ColorOutput "    [ERROR] Could not find component '$Component' in path" "Red"
                    
                    # Show available children for debugging
                    Write-ColorOutput "    [INFO] Available items at this level:" "Yellow"
                    $Children | ForEach-Object {
                        Write-ColorOutput "      - $($_.Name)" "DarkYellow"
                    }
                    
                    return $null
                }
                
                $CurrentItemId = $MatchingChild.Id
            }
            catch {
                Write-ColorOutput "    [ERROR] Failed to get children for component '$Component': $($_.Exception.Message)" "Red"
                return $null
            }
        }
        
        Write-ColorOutput "    [OK] Found item using folder navigation: $CurrentItemId" "Green"
        return $CurrentItemId
    }
    catch {
        Write-ColorOutput "    [ERROR] Folder navigation failed: $($_.Exception.Message)" "Red"
        return $null
    }
}

function Get-OneDriveOwnerFromCsv {
    param(
        [object]$Permission,
        [string]$InputCsvPath
    )
    
    # For organization-wide scan format, owner is directly available
    if ($Permission.PSObject.Properties.Name -contains "OneDriveOwnerEmail") {
        return $Permission.OneDriveOwnerEmail
    }
    
    # For single OneDrive scan format, try to extract from CSV filename or path
    try {
        $CsvFileName = Split-Path $InputCsvPath -Leaf
        
        # Look for email pattern in filename
        if ($CsvFileName -match '([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})') {
            return $matches[1]
        }
        
        # Look for username pattern in filename
        if ($CsvFileName -match '([a-zA-Z0-9._%+-]+)_OneDrivePermissions') {
            $Username = $matches[1]
            # This is a best guess - in production you might want to resolve this properly
            Write-ColorOutput "    [WARNING] Guessed OneDrive owner from filename: $Username" "Yellow"
            return $Username
        }
        
        # Fallback - return "Unknown" but warn
        Write-ColorOutput "    [WARNING] Could not determine OneDrive owner from single CSV format. Safety checks may be limited." "Yellow"
        return "Unknown"
        
    }
    catch {
        return "Unknown"
    }
}

#endregion

#region Permission Removal Functions

function Get-FirstNameFromEmail {
    param(
        [string]$Email
    )
    
    if (-not $Email -or -not ($Email -like "*@*")) {
        return $Email
    }
    
    $Username = $Email.Split('@')[0]
    
    # Handle common email formats
    if ($Username -like "j.*") { return "Janet" }  # j.harvey, j.smith
    if ($Username -like "*.j") { return "Janet" }  # harvey.j, smith.j
    if ($Username -match "^[a-z]harvey$") { return "Janet" }  # jharvey
    
    # Generic first letter extraction
    if ($Username -match "^([a-z])([a-z]+)$") {
        # First letter + rest (jharvey -> j)
        return $matches[1].ToUpper()
    }
    
    # Return the username if no pattern matches
    return $Username
}

function Suggest-UserFormat {
    param(
        [array]$CsvData
    )
    
    # Check if we have any data
    if (-not $CsvData -or $CsvData.Count -eq 0) {
        return $null
    }
    
    $SampleUsers = @()
    $UserColumns = @("TargetUserEmail", "TargetUserUPN", "TargetUserDisplayName", "UserEmail", "UserUPN", "UserDisplayName")
    
    # Find columns that might contain user information
    foreach ($Column in $UserColumns) {
        if ($CsvData[0].PSObject.Properties.Name -contains $Column) {
            # Get unique non-empty values
            $UniqueValues = $CsvData | 
                            Select-Object -ExpandProperty $Column -ErrorAction SilentlyContinue | 
                            Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | 
                            Select-Object -Unique -First 5
            
            foreach ($Value in $UniqueValues) {
                $SampleUsers += [PSCustomObject]@{
                    Column = $Column
                    Value = $Value
                }
            }
        }
    }
    
    return $SampleUsers
}

function Load-PermissionsCsv {
    param(
        [string]$CsvPath,
        [string]$TargetUser
    )
    
    try {
        Write-ColorOutput "Loading permissions data from: $CsvPath" "Yellow"
        
        if (-not (Test-Path $CsvPath)) {
            Write-ColorOutput "CSV file not found: $CsvPath" "Red"
            return $false
        }
        
        $CsvData = Import-Csv -Path $CsvPath
        
        if (-not $CsvData -or $CsvData.Count -eq 0) {
            Write-ColorOutput "CSV file is empty or invalid: $CsvPath" "Red"
            return $false
        }
        
        Write-ColorOutput "Loaded $($CsvData.Count) total permission entries from CSV" "Green"
        
        # Validate CSV format - check for required columns
        $RequiredColumns = @()
        
        # Detect CSV format based on columns
        if ($CsvData[0].PSObject.Properties.Name -contains "OneDriveOwnerEmail") {
            # Format from Scan-AllOneDrivesForUser.ps1
            $RequiredColumns = @("OneDriveOwnerEmail", "ItemPath", "PermissionId", "TargetUserEmail")
            Write-ColorOutput "Detected format: Organization-wide scan (Scan-AllOneDrivesForUser.ps1)" "Green"
        } else {
            # Format from Check-OneDrivePermissions.ps1
            $RequiredColumns = @("ItemPath", "PermissionId", "UserEmail")
            Write-ColorOutput "Detected format: Single OneDrive scan (Check-OneDrivePermissions.ps1)" "Green"
        }
        
        # Validate required columns exist
        foreach ($Column in $RequiredColumns) {
            if ($CsvData[0].PSObject.Properties.Name -notcontains $Column) {
                Write-ColorOutput "Missing required column: $Column" "Red"
                return $false
            }
        }
        
        # Filter for target user
        $FilteredData = @()
        
        # Debug: Show available columns in CSV
        if ($DebugMode) {
            Write-ColorOutput "DEBUG: Available columns in CSV:" "Magenta"
            $CsvData[0].PSObject.Properties.Name | ForEach-Object { Write-ColorOutput "  - $_" "Magenta" }
            
            # Show first few rows for debugging
            Write-ColorOutput "DEBUG: First 3 rows of CSV data:" "Magenta"
            $CsvData | Select-Object -First 3 | ForEach-Object {
                $Row = $_
                Write-ColorOutput "  Row data:" "Magenta"
                $Row.PSObject.Properties | ForEach-Object {
                    Write-ColorOutput "    $($_.Name): $($_.Value)" "Magenta"
                }
            }
        }
        
        # More flexible filtering logic
        if ($CsvData[0].PSObject.Properties.Name -contains "OneDriveOwnerEmail") {
            # Organization-wide scan format
            Write-ColorOutput "Using organization-wide scan format filtering" "Yellow"
            
            # Check which user-related columns exist
            $HasTargetUserEmail = $CsvData[0].PSObject.Properties.Name -contains "TargetUserEmail"
            $HasTargetUserUpn = $CsvData[0].PSObject.Properties.Name -contains "TargetUserUPN"
            $HasTargetUserDisplayName = $CsvData[0].PSObject.Properties.Name -contains "TargetUserDisplayName"
            
            if ($DebugMode) {
                Write-ColorOutput "DEBUG: HasTargetUserEmail: $HasTargetUserEmail" "Magenta"
                Write-ColorOutput "DEBUG: HasTargetUserUpn: $HasTargetUserUpn" "Magenta"
                Write-ColorOutput "DEBUG: HasTargetUserDisplayName: $HasTargetUserDisplayName" "Magenta"
            }
            
        # Try to determine if the target user is an email or a display name
        $IsEmail = $TargetUser -like "*@*"
        $Username = if ($IsEmail) { $TargetUser.Split('@')[0] } else { $TargetUser }
        
        Write-ColorOutput "Searching for user: $TargetUser (Format: $(if ($IsEmail) { 'Email' } else { 'Display Name' }))" "Yellow"
        
        # Special case for "Janet Harvey" / "jharvey@afsp.org" scenario
        # This handles the case where the display name is in the CSV but the email might be missing
        if ($IsEmail -and $Username -eq "jharvey" -and $HasTargetUserDisplayName) {
            Write-ColorOutput "Detected special case for jharvey@afsp.org - looking for Janet Harvey in display names" "Yellow"
            $FilteredData = $CsvData | Where-Object { 
                $_.TargetUserDisplayName -like "*Janet Harvey*" -or
                $_.TargetUserDisplayName -like "*Harvey, Janet*"
            }
            
            if ($FilteredData.Count -gt 0) {
                Write-ColorOutput "Found $($FilteredData.Count) entries for Janet Harvey by display name" "Green"
                $Script:PermissionsData = $FilteredData
                return $true
            }
        }
        
        # Build a more flexible filter with priority on exact matches
        $FilteredData = $CsvData | Where-Object { 
            # Exact matches first
            ($HasTargetUserEmail -and $_.TargetUserEmail -eq $TargetUser) -or
            ($HasTargetUserUpn -and $_.TargetUserUPN -eq $TargetUser) -or
            ($HasTargetUserDisplayName -and $_.TargetUserDisplayName -eq $TargetUser) -or
            
            # Then partial matches
            ($HasTargetUserEmail -and $_.TargetUserEmail -like "*$TargetUser*") -or
            ($HasTargetUserUpn -and $_.TargetUserUPN -like "*$TargetUser*") -or
            ($HasTargetUserDisplayName -and $_.TargetUserDisplayName -like "*$TargetUser*") -or
            
            # Then username-based matches (for email addresses)
            ($IsEmail -and $HasTargetUserEmail -and $_.TargetUserEmail -like "*$Username*") -or
            ($IsEmail -and $HasTargetUserUpn -and $_.TargetUserUPN -like "*$Username*") -or
            ($IsEmail -and $HasTargetUserDisplayName -and $_.TargetUserDisplayName -like "*$Username*") -or
            
            # Special case for first name matching when email is provided
            ($IsEmail -and $HasTargetUserDisplayName -and $_.TargetUserDisplayName -like "*$(Get-FirstNameFromEmail $TargetUser)*")
        }
        } else {
            # Single OneDrive scan format
            Write-ColorOutput "Using single OneDrive scan format filtering" "Yellow"
            
            # Check which user-related columns exist
            $HasUserEmail = $CsvData[0].PSObject.Properties.Name -contains "UserEmail"
            $HasUserUpn = $CsvData[0].PSObject.Properties.Name -contains "UserUPN"
            $HasUserDisplayName = $CsvData[0].PSObject.Properties.Name -contains "UserDisplayName"
            
            if ($DebugMode) {
                Write-ColorOutput "DEBUG: HasUserEmail: $HasUserEmail" "Magenta"
                Write-ColorOutput "DEBUG: HasUserUpn: $HasUserUpn" "Magenta"
                Write-ColorOutput "DEBUG: HasUserDisplayName: $HasUserDisplayName" "Magenta"
            }
            
            # Build a more flexible filter
            $FilteredData = $CsvData | Where-Object { 
                ($HasUserEmail -and ($_.UserEmail -eq $TargetUser -or $_.UserEmail -like "*$TargetUser*")) -or
                ($HasUserUpn -and ($_.UserUPN -eq $TargetUser -or $_.UserUPN -like "*$TargetUser*")) -or
                ($HasUserDisplayName -and $_.UserDisplayName -like "*$($TargetUser.Split('@')[0])*")
            }
        }
        
        if ($FilteredData.Count -eq 0) {
            Write-ColorOutput "No permissions found for target user: $TargetUser" "Yellow"
            
            # Get sample users from the CSV to suggest the correct format
            $SampleUsers = Suggest-UserFormat -CsvData $CsvData
            
            if ($SampleUsers -and $SampleUsers.Count -gt 0) {
                Write-ColorOutput "Sample users found in CSV:" "Yellow"
                $SampleUsers | ForEach-Object {
                    Write-ColorOutput "  - $($_.Value) (Column: $($_.Column))" "DarkYellow"
                }
                
                # Try to find the closest match to suggest
                $ClosestMatch = $null
                $Username = $TargetUser.Split('@')[0]
                
                foreach ($Sample in $SampleUsers) {
                    if ($Sample.Value -like "*$Username*") {
                        $ClosestMatch = $Sample.Value
                        break
                    }
                }
                
                if ($ClosestMatch) {
                    Write-ColorOutput "SUGGESTION: Try using this exact format: $ClosestMatch" "Green"
                }
            } else {
                Write-ColorOutput "No sample users found in the CSV file." "Yellow"
            }
            
            # Show available columns
            Write-ColorOutput "Available columns in CSV:" "Yellow"
            $CsvData[0].PSObject.Properties.Name | ForEach-Object { 
                Write-ColorOutput "  - $_" "DarkYellow" 
            }
            
            # Suggest a solution
            Write-ColorOutput "SUGGESTION: Try one of these approaches:" "Yellow"
            Write-ColorOutput "1. Check the CSV file manually to see the exact format of user emails" "Yellow"
            Write-ColorOutput "2. Run with -DebugMode switch to see more details about the CSV structure" "Yellow"
            Write-ColorOutput "3. Try using a partial email or username instead of the full email" "Yellow"
            Write-ColorOutput "4. If you know the exact format from the samples above, use that format" "Yellow"
            
            return $false
        }
        
        Write-ColorOutput "Found $($FilteredData.Count) permissions to process for user: $TargetUser" "Green"
        
        # Set the global variable to the filtered data
        $Script:PermissionsData = $FilteredData
        return $true
        
    }
    catch {
        Write-ColorOutput "Error loading CSV: $($_.Exception.Message)" "Red"
        return $false
    }
}

function Test-SafetyRules {
    param(
        [object]$Permission
    )
    
    # CRITICAL SAFETY RULE: Never remove permissions from user's own OneDrive
    $OneDriveOwner = ""
    $TargetUser = ""
    
    if ($Permission.PSObject.Properties.Name -contains "OneDriveOwnerEmail") {
        # Organization-wide scan format
        $OneDriveOwner = $Permission.OneDriveOwnerEmail
        $TargetUser = $Permission.TargetUserEmail
    } else {
        # Single OneDrive scan format - we need to determine OneDrive owner from context
        # In this case, we assume user provided the owner info or it's safe
        $TargetUser = $Permission.UserEmail
        # For single OneDrive scans, the owner should be provided via parameter or CSV context
        $OneDriveOwner = "Unknown"  # This should be handled better in production
    }
    
    # Safety check: Don't remove user's permissions from their own OneDrive
    if ($OneDriveOwner -eq $TargetUser) {
        Write-ColorOutput "[SHIELD] SAFETY BLOCK: Skipping removal from user's own OneDrive ($OneDriveOwner)" "Yellow"
        Add-AuditEntry -Message "SAFETY BLOCK: Skipped removal from user's own OneDrive" -Type "Safety" -OneDriveOwner $OneDriveOwner -ItemPath $Permission.ItemPath -Action "Skipped"
        $Script:SafetySkipped++
        return $false
    }
    
    return $true
}

function Remove-SinglePermission {
    param(
        [object]$Permission
    )
    
    $Script:ProcessedPermissions++
    
    try {
        # Extract permission details
        $PermissionId = $Permission.PermissionId
        $ItemPath = $Permission.ItemPath
        
        # Determine OneDrive owner with improved logic
        $OneDriveOwner = Get-OneDriveOwnerFromCsv -Permission $Permission -InputCsvPath $InputCsvPath
        
        # Apply safety rules
        if (-not (Test-SafetyRules -Permission $Permission)) {
            return $false
        }
        
        Write-ColorOutput "  [TARGET] Processing: $ItemPath (Owner: $OneDriveOwner)" "Yellow"
        
        if ($DryRun) {
            Write-ColorOutput "  [CLIPBOARD] DRY RUN: Would remove permission $PermissionId from $ItemPath" "Cyan"
            Add-AuditEntry -Message "DRY RUN: Would remove permission" -Type "DryRun" -OneDriveOwner $OneDriveOwner -ItemPath $ItemPath -PermissionId $PermissionId -Action "DryRun"
            $Script:RemovedPermissions++
            return $true
        }
        
        # ACTUAL REMOVAL LOGIC
        Write-ColorOutput "  [TOOL] Resolving Graph API resources..." "Yellow"
        
        # Step 1: Get OneDrive owner's drive ID
        $DriveId = Get-UserDriveId -UserEmail $OneDriveOwner
        if (-not $DriveId) {
            Write-ColorOutput "  [ERROR] Could not resolve OneDrive for owner: $OneDriveOwner" "Red"
            Add-AuditEntry -Message "Failed to resolve OneDrive for owner" -Type "Error" -OneDriveOwner $OneDriveOwner -ItemPath $ItemPath -PermissionId $PermissionId -Action "Error"
            $Script:ErrorPermissions += $Permission
            return $false
        }
        
        # Step 2: Find the item in the drive
        $ItemId = Find-DriveItemByPath -DriveId $DriveId -ItemPath $ItemPath
        if (-not $ItemId) {
            Write-ColorOutput "  [ERROR] Could not find item: $ItemPath" "Red"
            Add-AuditEntry -Message "Failed to find item in OneDrive" -Type "Error" -OneDriveOwner $OneDriveOwner -ItemPath $ItemPath -PermissionId $PermissionId -Action "Error"
            $Script:ErrorPermissions += $Permission
            return $false
        }
        
        # Step 3: Remove the specific permission
        Write-ColorOutput "  [DELETE] Removing permission: $PermissionId" "Yellow"
        
        try {
            Remove-MgDriveItemPermission -DriveId $DriveId -DriveItemId $ItemId -PermissionId $PermissionId -ErrorAction Stop
            Write-ColorOutput "  [OK] Successfully removed permission!" "Green"
            Add-AuditEntry -Message "Successfully removed permission" -Type "Success" -OneDriveOwner $OneDriveOwner -ItemPath $ItemPath -PermissionId $PermissionId -Action "Removed"
            $Script:RemovedPermissions++
            return $true
        }
        catch {
            Write-ColorOutput "  [ERROR] Failed to remove permission: $($_.Exception.Message)" "Red"
            Add-AuditEntry -Message "Failed to remove permission: $($_.Exception.Message)" -Type "Error" -OneDriveOwner $OneDriveOwner -ItemPath $ItemPath -PermissionId $PermissionId -Action "Error"
            $Script:ErrorPermissions += $Permission
            return $false
        }
        
    }
    catch {
        Write-ColorOutput "  [ERROR] Unexpected error removing permission: $($_.Exception.Message)" "Red"
        Add-AuditEntry -Message "Unexpected error: $($_.Exception.Message)" -Type "Error" -OneDriveOwner $OneDriveOwner -ItemPath $ItemPath -PermissionId $PermissionId -Action "Error"
        $Script:ErrorPermissions += $Permission
        return $false
    }
}

function Show-RemovalPreview {
    Write-ColorOutput "==========================================" "Cyan"
    Write-ColorOutput "PERMISSION REMOVAL PREVIEW" "Cyan"
    Write-ColorOutput "==========================================" "Cyan"
    Write-Host ""
    
    Write-ColorOutput "Target User: $TargetUserEmail" "White"
    Write-ColorOutput "Total Permissions to Process: $($Script:PermissionsData.Count)" "White"
    Write-ColorOutput "Dry Run Mode: $DryRun" "White"
    Write-Host ""
    
    # Group by OneDrive owner
    $GroupedPermissions = @{}
    
    foreach ($Permission in $Script:PermissionsData) {
        $Owner = if ($Permission.PSObject.Properties.Name -contains "OneDriveOwnerEmail") { $Permission.OneDriveOwnerEmail } else { "Unknown Owner" }
        
        if (-not $GroupedPermissions.ContainsKey($Owner)) {
            $GroupedPermissions[$Owner] = @()
        }
        $GroupedPermissions[$Owner] += $Permission
    }
    
    Write-ColorOutput "Permissions by OneDrive Owner:" "Yellow"
    foreach ($Owner in $GroupedPermissions.Keys) {
        $Count = $GroupedPermissions[$Owner].Count
        
        # Apply safety check for preview
        if ($Owner -eq $TargetUserEmail) {
            Write-ColorOutput "  [SHIELD] $Owner - $Count permission(s) [WILL BE SKIPPED - USER'S OWN ONEDRIVE]" "Yellow"
        } else {
            Write-ColorOutput "  [OK] $Owner - $Count permission(s) [WILL BE PROCESSED]" "Green"
        }
    }
    
    Write-Host ""
    
    if (-not $Force) {
        $Response = Read-Host "Do you want to proceed? (y/n)"
        if ($Response -ne 'y' -and $Response -ne 'Y') {
            Write-ColorOutput "Operation cancelled by user." "Yellow"
            return $false
        }
    }
    
    return $true
}

function Export-AuditLog {
    param(
        [string]$LogPath
    )
    
    try {
        if ($Script:AuditLog.Count -gt 0) {
            $Script:AuditLog | Export-Csv -Path $LogPath -NoTypeInformation -Encoding UTF8
            Write-ColorOutput "Audit log exported to: $LogPath" "Green"
        }
    }
    catch {
        Write-ColorOutput "Error exporting audit log: $($_.Exception.Message)" "Red"
    }
}

#endregion

#region Main Script

function Main {
    # Display banner
    Write-ColorOutput "=============================================" "Cyan"
    Write-ColorOutput "OneDrive Permission Removal Tool" "Cyan"
    Write-ColorOutput "=============================================" "Cyan"
    Write-Host ""
    
    if ($DryRun) {
        Write-ColorOutput "[SEARCH] DRY RUN MODE - No actual changes will be made" "Yellow"
    } else {
        Write-ColorOutput "[WARNING] LIVE MODE - Permissions will be removed!" "Red"
    }
    Write-Host ""
    
    # Install required modules
    if (-not (Install-RequiredModules)) {
        Write-ColorOutput "Failed to install required modules. Exiting." "Red"
        return
    }
    
    # Copy parameters to script scope for global access
    $Script:AuthMethod = if ($AuthMethod) { $AuthMethod } else { $null }
    $Script:TenantId = $TenantId
    $Script:ClientId = $ClientId
    $Script:CertificatePath = $CertificatePath
    $Script:CertificatePassword = $CertificatePassword
    $Script:ClientSecret = $ClientSecret
    
    # Get user input if parameters not provided
    if (-not $InputCsvPath) {
        $InputCsvPath = Get-UserInput "Enter path to CSV file from permission scan" -IsFilePath
    }
    
    if (-not $TargetUserEmail) {
        $TargetUserEmail = Get-UserInput "Enter email of user whose permissions to remove"
    }
    
    if (-not $LogPath) {
        $Timestamp = Get-Date -Format 'yyyyMMdd_HHmmss'
        $SafeTargetUser = $TargetUserEmail.Replace('@','_').Replace('.','_')
        $LogPath = Join-Path (Get-Location) "PermissionRemoval_${SafeTargetUser}_$Timestamp.csv"
    }
    
    # Load and validate CSV data
    if (-not (Load-PermissionsCsv -CsvPath $InputCsvPath -TargetUser $TargetUserEmail)) {
        Write-ColorOutput "Failed to load or validate CSV data. Exiting." "Red"
        return
    }
    
    # Show preview and get confirmation
    if (-not (Show-RemovalPreview)) {
        Write-ColorOutput "Operation cancelled." "Yellow"
        return
    }
    
    # Always setup authentication details, even in dry run mode
    # This ensures we get the certificate password
    if (-not (Get-AuthenticationDetails)) {
        Write-ColorOutput "Failed to setup authentication. Exiting." "Red"
        return
    }
    
    # Only connect to Graph if not in dry run mode
    if (-not $DryRun) {
        # Connect to Microsoft Graph
        if (-not (Connect-ToGraph)) {
            Write-ColorOutput "Failed to connect to Microsoft Graph. Exiting." "Red"
            return
        }
    }
    
    # Initialize start time
    $Script:StartTime = Get-Date
    
    # Process permissions
    Write-ColorOutput "Starting permission removal process..." "Yellow"
    Write-Host ""
    
    $BatchCount = 0
    $TotalBatches = [Math]::Ceiling($Script:PermissionsData.Count / $BatchSize)
    
    for ($i = 0; $i -lt $Script:PermissionsData.Count; $i += $BatchSize) {
        $BatchCount++
        $Batch = $Script:PermissionsData[$i..([Math]::Min($i + $BatchSize - 1, $Script:PermissionsData.Count - 1))]
        
        Write-ColorOutput "Processing batch $BatchCount of $TotalBatches ($($Batch.Count) permissions)..." "Yellow"
        
        foreach ($Permission in $Batch) {
            Remove-SinglePermission -Permission $Permission
            
            # Small delay to avoid rate limiting
            Start-Sleep -Milliseconds 200
        }
        
        # Progress update
        $Progress = [Math]::Round(($Script:ProcessedPermissions / $Script:PermissionsData.Count) * 100, 1)
        Write-ColorOutput "Progress: $Progress% ($($Script:ProcessedPermissions)/$($Script:PermissionsData.Count))" "Green"
        
        # Longer delay between batches
        if ($BatchCount -lt $TotalBatches) {
            Start-Sleep -Seconds 2
        }
    }
    
    # Final summary
    $EndTime = Get-Date
    $Duration = $EndTime - $Script:StartTime
    
    Write-Host ""
    Write-ColorOutput "========================================" "Cyan"
    Write-ColorOutput "PERMISSION REMOVAL SUMMARY" "Cyan"
    Write-ColorOutput "========================================" "Cyan"
    Write-ColorOutput "Target User: $TargetUserEmail" "White"
    Write-ColorOutput "Total Processed: $($Script:ProcessedPermissions)" "White"
    Write-ColorOutput "Successfully Removed: $($Script:RemovedPermissions)" "Green"
    Write-ColorOutput "Safety Skipped: $($Script:SafetySkipped)" "Yellow"
    Write-ColorOutput "Errors: $($Script:ErrorPermissions.Count)" "Red"
    $DurationText = "$([Math]::Round($Duration.TotalSeconds, 1)) seconds"
    Write-ColorOutput "Duration: $DurationText" "White"
    $ModeText = if ($DryRun) { 'DRY RUN' } else { 'LIVE' }
    Write-ColorOutput "Mode: $ModeText" "White"
    
    if ($Script:ErrorPermissions.Count -gt 0) {
        Write-Host ""
        Write-ColorOutput "Errors encountered:" "Red"
        foreach ($ErrorPerm in $Script:ErrorPermissions) {
            Write-ColorOutput "  - $($ErrorPerm.ItemPath)" "Red"
        }
    }
    
    # Export audit log
    Export-AuditLog -LogPath $LogPath
    
    # Disconnect from Graph
    if (-not $DryRun) {
        try {
            Disconnect-MgGraph | Out-Null
            Write-ColorOutput "Disconnected from Microsoft Graph." "Green"
        }
        catch {
            # Ignore disconnect errors
        }
    }
    
    Write-Host ""
    if ($DryRun) {
        Write-ColorOutput "[SEARCH] DRY RUN COMPLETED - No actual changes were made" "Yellow"
        Write-ColorOutput "To perform actual removal, run with -DryRun `$false" "Yellow"
    } else {
        Write-ColorOutput "[OK] PERMISSION REMOVAL COMPLETED" "Green"
    }
}

# Execute main function
try {
    Main
}
catch {
    Write-ColorOutput "Critical error: $($_.Exception.Message)" "Red"
    Write-ColorOutput "Stack trace: $($_.ScriptStackTrace)" "Red"
    
    # Ensure we disconnect from Graph on error
    try {
        Disconnect-MgGraph | Out-Null
    }
    catch {
        # Ignore disconnect errors
    }
    
    exit 1
}

#endregion
